=== Composite views

TODO: Build out an example in the example_app with composite views.

The +SwappingRouter+ above calls +leave()+ on the view it currently holds.  
This function is not part of Backbone itself, and is part of our extension 
library to help make views more modular and maintainable. This section goes 
over the Composite View pattern, the +CompositeView+ class itself, and some 
concerns to keep in mind while creating your views.

==== Refactoring from a large view

One of the first refactorings you find yourself doing in a non-trivial Backbone
app is splitting up large views into composable parts. Let's take another look
at the +TaskDetail+ source code from the beginning of this section:

[javascript]
source~~~~
include::task_detail_view_class.js[]
source~~~~

The view class references a template, which renders out the HTML for this page:

[xml]
source~~~~
<section class="task-details">
  <input type="checkbox"<%= task.isComplete() ? ' checked="checked"' : '' %> />
  <h2><%= task.escape("title") %></h2>
</section>

<section class="comments">
  <ul>
    <% task.comments.each(function(comment) { %>
      <li>
        <h4><%= comment.user.escape('name') %></h4>
        <p><%= comment.escape('text') %></p>
      </li>
    <% } %>
  </ul>

  <div class="form-inputs">
    <label for="new-comment-input">Add comment</label>
    <textarea id="new-comment-input" cols="30" rows="10"></textarea>
    <button>Add Comment</button>
  </div>
</section>
source~~~~

There are clearly several concerns going on here: rendering the task, rendering
the comments that folks have left, and rendering the form to create new
comments. Let's separate those concerns. A first approach might be to just
break up the template files:

[xml]
source~~~~
<!-- tasks/show.jst -->
<section class="task-details">
  <%= JST['tasks/details']({ task: task }) %>
</section>

<section class="comments">
  <%= JST['comments/list']({ task: task }) %>
</section>
source~~~~

[xml]
source~~~~
<!-- tasks/details.jst -->
<input type="checkbox"<%= task.isComplete() ? ' checked="checked"' : '' %> />
<h2><%= task.escape("title") %></h2>
source~~~~

[xml]
source~~~~
<!-- comments/list.jst -->
<ul>
  <% task.comments.each(function(comment) { %>
    <%= JST['comments/item']({ comment: comment }) %>
  <% } %>
</ul>

<%= JST['comments/new']() %>
source~~~~

[xml]
source~~~~
<!-- comments/item.jst -->
<h4><%= comment.user.escape('name') %></h4>
<p><%= comment.escape('text') %></p>
source~~~~

[xml]
source~~~~
<!-- comments/new.jst -->
<div class="form-inputs">
  <label for="new-comment-input">Add comment</label>
  <textarea id="new-comment-input" cols="30" rows="10"></textarea>
  <button>Add Comment</button>
</div>
source~~~~

But this is really only half the story. The +TaskDetail+ view class still
handles multiple concerns: displaying the task, and creating comments. Let's
split that view class up, using the +CompositeView+ base class:

[javascript]
source~~~~
include::composite_view.js[]
source~~~~

TODO: Re-link to swapping-internals anchor once https://github.com/schacon/git-scribe/issues/33 is fixed

Similar to the +SwappingRouter+, the +CompositeView+ base class solves common
housekeeping problems by establishing a convention. See the Swapping Router and
Backbone internals section for an in-depth analysis of how this subclassing
pattern works.

Now our +CompositeView+ maintains an array of its immediate children as 
+this.children+.  With this reference in place, a parent view's +leave()+ method
can invoke +leave()+ on its children, ensuring that an entire tree of composed
views is cleaned up properly.

For child views that can dismiss themselves, such as dialog boxes, children
maintain a back-reference at +this.parent+. This is used to reach up and call
+this.parent.removeChild(this)+ for these self-dismissing views.

Making use of +CompositeView+, we split up the +TaskDetail+ view class:

[javascript]
source~~~~
var TaskDetail = CompositeView.extend({
  tagName: 'section',
  id: 'task',

  initialize: function() {
    _.bindAll(this, "renderDetails");
    this.model.bind("change", this.renderDetails);
  },

  render: function() {
    this.renderLayout();
    this.renderDetails();
    this.renderCommentsList();
  },

  renderLayout: function() {
    $(this.el).html(JST['tasks/show']());
  },

  renderDetails: function() {
    var detailsMarkup = JST['tasks/details']({ task: this.model });
    this.$('.task-details').html(detailsMarkup);
  },

  renderCommentsList: function() {
    var commentsList = new CommentsList({ model: this.model });
    var commentsContainer = this.$('comments');
    this.renderChildInto(commentsList, commentsContainer);
  }
});
source~~~~

[javascript]
source~~~~
var CommentsList = CompositeView.extend({
  tagName: 'ul',

  initialize: function() {
    this.model.comments.bind("add", this.renderComments);
  },

  render: function() {
    this.renderLayout();
    this.renderComments();
    this.renderCommentForm();
  },

  renderLayout: function() {
    $(this.el).html(JST['comments/list']());
  },

  renderComments: function() {
    var commentsContainer = this.$('comments-list');
    commentsContainer.html('');

    this.model.comments.each(function(comment) {
      var commentMarkup = JST['comments/item']({ comment: comment });
      commentsContainer.append(commentMarkup);
    });
  },

  renderCommentForm: function() {
    var commentForm = new CommentForm({ model: this.model });
    var commentFormContainer = this.$('.new-comment-form');
    this.renderChildInto(commentForm, commentFormContainer);
  }
});
source~~~~

[javascript]
source~~~~
var CommentForm = CompositeView.extend({
  events: {
    "click button": "createComment"
  },

  initialize: function() {
    this.model = this.options.model;
  },

  render: function() {
    $(this.el).html(JST['comments/new']);
  },

  createComment: function() {
    var comment = new Comment({ text: $('.new-comment-input').val() });
    this.$('.new-comment-input').val('');
    this.model.comments.create(comment);
  }
});
source~~~~

Along with this, remove the +<%= JST(...) %>+ template nestings, allowing the
view classes to assemble the templates instead. In this case, each template
contains placeholder elements that are used to wrap child views:

[xml]
source~~~~
<!-- tasks/show.jst -->
<section class="task-details">
</section>

<section class="comments">
</section>
source~~~~

[xml]
source~~~~
<!-- tasks/details.jst -->
<input type="checkbox"<%= task.isComplete() ? ' checked="checked"' : '' %> />
<h2><%= task.escape("title") %></h2>
source~~~~

[xml]
source~~~~
<!-- comments/list.jst -->
<ul class="comments-list">
</ul>

<section class="new-comment-form">
</section>
source~~~~

[xml]
source~~~~
<!-- comments/item.jst -->
<h4><%= comment.user.escape('name') %></h4>
<p><%= comment.escape('text') %></p>
source~~~~

[xml]
source~~~~
<!-- comments/new.jst -->
<label for="new-comment-input">Add comment</label>
<textarea class="new-comment-input" cols="30" rows="10"></textarea>
<button>Add Comment</button>
source~~~~

There are several advantages to this approach:

- Each view class has a smaller and more cohesive set of responsibilities.
- The comments view code, extracted and decoupled from the task view code, can
  now be reused on other domain objects with comments.
- The task view performs better, since adding new comments or updating the task
  details will only re-render the pertinent section, instead of re-rendering the
  entire task + comments composite.

==== Cleaning up views properly

We now have a full set of tools to clean up views properly.

TODO: Wrap up and re-state the "cleaning up, swappingrouter, compositeview" sections.  Mix +Observer+ into +CompositeView+.
